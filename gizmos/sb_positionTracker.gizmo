#! C:/Program Files/Nuke10.5v1/nuke-10.5.1.dll -nx
version 10.5 v1
Group {
name sb_PositionTracker
inputs 3
help "sb_positionTracker\nVersion 2.1\nSimon Bjork\nbjork.simon@gmail.com\nwww.bjorvisuals.com\n"
tile_color 0xff00ffff
note_font Verdana
mapsize {0.15 0.15}
addUserKnob {20 controls}
addUserKnob {12 bl l INVISIBLE +INVISIBLE}
addUserKnob {12 br l INVISIBLE +INVISIBLE}
addUserKnob {12 ur l INVISIBLE +INVISIBLE}
addUserKnob {12 ul l INVISIBLE +INVISIBLE}
addUserKnob {26 divider1 l "" +STARTLINE}
addUserKnob {41 in l "position channel" T position_to_rgb.in}
addUserKnob {26 divider2 l "" +STARTLINE}
addUserKnob {26 three3_pos l "<b>3D postions</b>" T " "}
addUserKnob {26 info l "" +STARTLINE T "Hold down Ctrl+Shift+Alt to sample."}
addUserKnob {41 bl_sampler l "bottom left" T pt_sampler.bl_sampler}
addUserKnob {41 br_sampler l "bottom right" T pt_sampler.br_sampler}
addUserKnob {41 ur_sampler l "upper right" T pt_sampler.ur_sampler}
addUserKnob {41 ul_sampler l "upper left" T pt_sampler.ul_sampler}
addUserKnob {22 color_sample_bbox l "color sample bbox" t "Sample the corners of the color sample bbox instead of manually sample each corner.\n\n<b>Note: This seems buggy and sometimes doesn't sample all corners.</b>" T "def _sample_viewer_bbox():\n\n    n = nuke.thisNode()\n\n    try:\n        bboxinfo = nuke.activeViewer().node()\['colour_sample_bbox'].value()\n    except:\n        print(\"No bbox.\")\n        return\n\n    # Mads stuff from QuickCreate.    \n    aspect = float(n.width()*n.pixelAspect())/float(n.height())\n    bl = \[(bboxinfo\[0]*0.5+0.5)*n.width(),(((bboxinfo\[1]*0.5)+(0.5/aspect))*aspect)*n.height()] #Get the button left corner\n    ur = \[(bboxinfo\[2]*0.5+0.5)*n.width(),(((bboxinfo\[3]*0.5)+(0.5/aspect))*aspect)*n.height()] #Get the top right corner\n    br = \[ur\[0], bl\[1]]\n    ul = \[bl\[0], ur\[1]]\n\n    f = int(nuke.root()\[\"frame\"].value())\n    layer = n\[\"in\"].value()\n\n    with n:\n        sampler_node = nuke.toNode(\"pt_sampler\")\n\n    channels = \[x for x in sampler_node.channels() if x.split(\".\")\[0].startswith(layer)]\n    if len(channels) > 3:\n        channels = channels\[0:3]\n\n    for corner, knob in zip(\[bl, br, ur, ul], \[\"bl_sampler\", \"br_sampler\", \"ur_sampler\", \"ul_sampler\"]):\n        rgb = \[]\n        for c in channels:\n            s = sampler_node.sample(c, corner\[0], corner\[1], 1, 1, f)\n            rgb.append(s)\n        n\[knob].setValue(rgb)\n\n_sample_viewer_bbox()" +STARTLINE}
addUserKnob {26 divider3 l "" +STARTLINE}
addUserKnob {22 gen_keys l "generate keyframes" T "################\n\n\"\"\"\n\tsbPositionTracker_generateKeyframes():\n\tSimon Bjork\n\tMarch 2014\n\n\tUpdate (2021-04-12):\n\t - Try to fix issues when a point is behind the camera.\n\n\n\n\tGenerate 2d keyframes from color sample.\n\n\tUpdated some of the nukescripts.snap3d functions to accept a frame and format argument.\n\tIvan Busquets posted the code to give the frame argument to CameraProjectionMatrix()\n\thttp://forums.thefoundry.co.uk/phpBB2/viewtopic.php?p=26502&sid=90d2f80543be7b2bf2decbeb556eaea7\n\n\"\"\"\n\n################\n\nimport nuke\nimport _nukemath\nimport nukescripts\nimport math\n\n################\n\ndef _getWorldMatrix(node, frame):\t\n\tmatrixList = node\[\"world_matrix\"].valueAt(frame)\n\t\n\t# Reorder list and put it into a matrix.\n\torder = \[0,4,8,12,1,5,9,13,2,6,10,14,3,7,11,15]\n\t\n\tmatrix = _nukemath.Matrix4()\t\n\tfor i in range(16):\n\t\tmatrix\[i] = matrixList\[ order\[i] ]\n\n\treturn matrix\n\n\ndef _cameraProjectionMatrix(cameraNode, _format, frame):\n\n\t#Calculate the projection matrix for the camera, based on it's knob values.\n\n\tworldMatrix = _getWorldMatrix(cameraNode, frame)\n\tcamTransform = worldMatrix.inverse()\n\n\t# Matrix to take the camera projection knobs into account \n\troll = float(cameraNode\['winroll'].getValueAt(frame)) \n\tscale_x, scale_y = \[float(v) for v in cameraNode\['win_scale'].getValueAt(frame)] \n\ttranslate_x, translate_y = \[float(v) for v in cameraNode\['win_translate'].getValueAt(frame)] \n\tm = _nukemath.Matrix4() \n\tm.makeIdentity() \n\tm.rotateZ(math.radians(roll)) \n\tm.scale(1.0 / scale_x, 1.0 / scale_y, 1.0) \n\tm.translate(-translate_x, -translate_y, 0.0)\n\n\t# Projection matrix based on the focal length, aperture and clipping planes of the camera \n\tfocal_length = float(cameraNode\['focal'].getValueAt(frame)) \n\th_aperture = float(cameraNode\['haperture'].getValueAt(frame)) \n\tnear = float(cameraNode\['near'].getValueAt(frame)) \n\tfar = float(cameraNode\['far'].getValueAt(frame)) \n\tprojection_mode = int(cameraNode\['projection_mode'].getValueAt(frame)) \n\tp = _nukemath.Matrix4() \n\tp.projection(focal_length / h_aperture, near, far, projection_mode == 0)\n\n\t# Matrix to translate the projected points into normalised pixel coords. \n\timageAspect = float(_format.height()) / float(_format.width())\n\tt = _nukemath.Matrix4()\n\tt.makeIdentity() \n\tt.translate( 1.0, 1.0 - (1.0 - imageAspect / float(_format.pixelAspect())), 0.0 )\n\n\t# Matrix to scale normalised pixel coords into actual pixel coords. \n\tx_scale = float(_format.width()) / 2.0 \n\ty_scale = x_scale * _format.pixelAspect() \n\ts = _nukemath.Matrix4() \n\ts.makeIdentity()\n\ts.scale(x_scale, y_scale, 1.0)\n\n\t# The projection matrix transforms points into camera coords, modifies based \n\t# on the camera knob values, projects points into clip coords, translates the \n\t# clip coords so that they lie in the range 0,0 - 2,2 instead of -1,-1 - 1,1, \n\t# then scales the clip coords to proper pixel coords. \n\treturn s * t * p * m * camTransform\n\n# Updated version.\ndef _projectPoints(camMatrix, points=None, _format=None, frame=None):\n\n\t# camNode = None\n\t# if isinstance(camera, nuke.Node):\n\t# \tcamNode = camera\n\t# elif isinstance(camera, str):\n\t# \tcamNode = nuke.toNode(camera)\n\t# else:\n\t# \traise ValueError(\"Argument camera must be a node or the name of a node.\")\n\n\t# camMatrix = _cameraProjectionMatrix(camNode, _format, frame)\n\n\t# if camMatrix == None:\n\t# \traise RuntimeError(\"snap3d.cameraProjectionMatrix() returned None for camera.\")\n\n\tif not ( isinstance(points, list) or isinstance(points, tuple) ):\n\t\traise ValueError(\"Argument points must be a list or tuple.\")\n\n\tfor point in points:\n\t\t# Would be nice to not do this for every item but since lists/tuples can\n\t\t# containg anything...\n\t\tif isinstance(point, nuke.math.Vector3):\n\t\t\tpt = point\n\t\telif isinstance(point, list) or isinstance(point, tuple):\n\t\t\tpt = nuke.math.Vector3(point\[0], point\[1], point\[2])\n\t\telse:\n\t\t\traise ValueError(\"All items in points must be nuke.math.Vector3 or list/tuple of 3 floats.\")\n\n\t\ttPos = camMatrix * nuke.math.Vector4(pt.x, pt.y, pt.z, 1.0)\n\t\tyield nuke.math.Vector2(tPos.x / tPos.w, tPos.y / tPos.w)\n\n# Updated version.\ndef _projectPoint(camMatrix, point=None, _format=None, frame=None):\t\n\treturn next(_projectPoints(camMatrix, (point,), _format, frame ))\n\ndef getCameraInput(node, input):\n\n\t# Get the connected camera, igoring dots and everything else between.    \n\tfound = False \n\t\n\twhile not found:\n\n\t\t# Get input.        \n\t\tcurrInput = node.input(input)\n\t\t\n\t\t# If no input is found, return False.\n\t\tif currInput == \"\" or currInput == None:\n\t\t\treturn False\n\n\t\tif not currInput.Class() in \[\"Camera\", \"Camera2\"]:\n\t\t\t# If not found, keep looking.\n\t\t\treturn getCameraInput(currInput, 0) \n\t\telse: \n\t\t\tfound = True \n\t\t\treturn currInput\n\ndef sbPositionTracker_generateKeyframes():\n\n\tn = nuke.thisNode()\n\n\tp = nuke.Panel (\"Set frame-range\")\n\tp.addSingleLineInput('Start', int(nuke.root()\[\"first_frame\"].value()))\n\tp.addSingleLineInput('End', int(nuke.root()\[\"last_frame\"].value()))\n\tresult=p.show()\n\n\tif not result:\n\t\tprint(\"Cancelled by user.\")\n\t\treturn\n\n\tcam = getCameraInput(n, 2)\n\n\tif not cam:\n\t\tnuke.message(\"Connect a camera.\")\n\t\treturn\n\n\t_format = n.format()\n\n\tknob_names = \[\"bl\", \"br\", \"ur\", \"ul\"]\n\n\tfor k in knob_names:\n\t\tn\[k].clearAnimated()\n\t\tn\[k].setAnimated()\n\n\t# First and last frame.\n\tff = int(p.value('Start'))\n\tlf = int(p.value('End'))\n\n\t# Setup progress bar.\n\ttask = nuke.ProgressTask('Generating keyframes...')\n\tprogressCalc = 100.0/float(lf-ff)\n\tcounter = 0\n\n\t# Get the sampled values.\n\tbl_sample = n\[\"bl_sampler\"].value()\n\tbr_sample = n\[\"br_sampler\"].value()\n\tur_sample = n\[\"ur_sampler\"].value()\n\tul_sample = n\[\"ul_sampler\"].value()\n\n\t# Create Vector4 so we can multiply with matrix.\n\tbl_vec4 = nuke.math.Vector4(bl_sample\[0], bl_sample\[1], bl_sample\[2], 1)\n\tbr_vec4 = nuke.math.Vector4(br_sample\[0], br_sample\[1], br_sample\[2], 1)\n\tur_vec4 = nuke.math.Vector4(ur_sample\[0], ur_sample\[1], ur_sample\[2], 1)\n\tul_vec4 = nuke.math.Vector4(ul_sample\[0], ul_sample\[1], ul_sample\[2], 1)\t\n\n\t# Loop over the frame range.\n\tfor frame in range(ff, lf+1):\n\n\t\tif task.isCancelled():\n\t\t\tprint(\"Cancelled by user.\")\n\t\t\t# Set knob values.\n\t\t\tn\[\"ff\"].setValue(ff)\n\t\t\tn\[\"lf\"].setValue(frame-1)\n\t\t\tn\[\"keyframes_exists\"].setValue(\"Keyframes generated between \{0\}-\{1\}.\".format(ff, frame-1))\n\t\t\treturn\n\n\t\t# Get the camera projection matrix.\n\t\tcamMatrix = _cameraProjectionMatrix(cam, _format, frame)\n\n\t\t# Convert 3d to 2d.\n\t\t# If the 3d point is behind the camera, skip (and later interpolate instead).\t\n\t\tbl_distance = camMatrix * bl_vec4\n\t\tif bl_distance.z > 0:\n\t\t\tbl2d = _projectPoint(camMatrix, bl_sample, _format, frame)\n\t\t\tn\[\"bl\"].setValueAt(bl2d\[0], frame, 0)\n\t\t\tn\[\"bl\"].setValueAt(bl2d\[1], frame, 1)\n\t\t\n\t\tbr_distance = camMatrix * br_vec4\n\t\tif br_distance.z > 0:\n\t\t\tbr2d = _projectPoint(camMatrix, br_sample, _format, frame)\n\t\t\tn\[\"br\"].setValueAt(br2d\[0], frame, 0)\n\t\t\tn\[\"br\"].setValueAt(br2d\[1], frame, 1)\t\t\n\n\t\tur_distance = camMatrix * ur_vec4\n\t\tif ur_distance.z > 0:\n\t\t\tur2d = _projectPoint(camMatrix, ur_sample, _format, frame)\n\t\t\tn\[\"ur\"].setValueAt(ur2d\[0], frame, 0)\n\t\t\tn\[\"ur\"].setValueAt(ur2d\[1], frame, 1)\n\t\t\n\t\tul_distance = camMatrix * ul_vec4\n\t\tif ul_distance.z > 0:\n\t\t\tul2d = _projectPoint(camMatrix, ul_sample, _format, frame)\n\t\t\tn\[\"ul\"].setValueAt(ul2d\[0], frame, 0)\n\t\t\tn\[\"ul\"].setValueAt(ul2d\[1], frame, 1)\n\n\t\t# Update progress bar.\n\t\ttask.setProgress(int(counter*progressCalc))\n\t\ttask.setMessage(\"Frame \{0\}\".format(frame))\n\t\tcounter +=1\n\n\t# Delete progress bar.\n\tdel task\n\n\t# Set knob values.\n\tn\[\"ff\"].setValue(ff)\n\tn\[\"lf\"].setValue(lf)\n\tn\[\"keyframes_exists\"].setValue(\"Keyframes generated between \{0\}-\{1\}.\".format(ff, lf))\n\n\t# Loop over the animations and set linear interpolation before/after keys.\n\t# This will (hopefully) fix points that are behind the camera.\n\t# Currently this operates on all keyframes instead of only the ones that really need it,\n\t# but it's not a big problem.\n\tfor k in knob_names:\n\t\tknob = n\[k]\n\t\tfor anim in knob.animations():\n\t\t\tkeys = anim.keys()\n\t\t\tif not keys:\n\t\t\t\tcontinue\n\n\t\t\t# Set the interpolation.\n\t\t\tanim.changeInterpolation(keys, nuke.BEFORE_LINEAR)\n\t\t\tanim.changeInterpolation(keys, nuke.AFTER_LINEAR)\n\nsbPositionTracker_generateKeyframes()" +STARTLINE}
addUserKnob {22 reset_val l reset -STARTLINE T "n = nuke.thisNode()\n\nfor i in \[\"bl\", \"br\",\"ur\", \"ul\"]:\n\tn\[\"\{0\}_sampler\".format(i)].setValue(\[0,0,0])\n\tn\[i].clearAnimated()\n\tn\[i].setValue(\[0,0])\n\nn\[\"ff\"].setValue(1)\nn\[\"lf\"].setValue(1)\n\nn\[\"keyframes_exists\"].setValue(\"No keyframes generated.\")"}
addUserKnob {3 ff l INVISIBLE +INVISIBLE}
ff 1
addUserKnob {3 lf l INVISIBLE +INVISIBLE}
lf 1
addUserKnob {26 keyframes_exists l "" +STARTLINE T "No keyframes generated."}
addUserKnob {26 divider4 l "" +STARTLINE}
addUserKnob {4 output_node l output M {"CornerPin Match-move (Plane)" "CornerPin Stabilize (Plane)" Tracker RotoPaint GridWarp SplineWarp ""}}
addUserKnob {3 ref_frame l "reference frame"}
ref_frame 1
addUserKnob {22 set_frame l "set to this frame" -STARTLINE T "n = nuke.thisNode()\nf = nuke.frame()\nn\[\"ref_frame\"].setValue(f)"}
addUserKnob {26 divider5 l "" +STARTLINE}
addUserKnob {22 create_node l "<b><font color=\"green\"><size><font size=\"4\">create node</font size></font></b>" T "##################################################\n\n\n# Simon Bjork\n# March 2014\n# April 2021: Updated  to speed up creation of trackers.\n#\n# Create nodes.\n#\n# Note! Make sure to use no triple quotes anywhere in this script! I don't know why, but if there's a triple quote in this script the copy/paste will break.\n#\n# TODO:\n# - Speed up GridWarp by using setting keys on the AnimCurve instead of setValue.\n# - Can we create a default grid for the GridWarp based on corners? Have a look in h_viewerShortcuts.py by Mads Hagbarth Damsbo.\n\n\n##################################################\n\n\nimport nuke\nimport nuke.rotopaint as rp\nimport threading\n\n\n##################################################\n\n\ndef pointsToMatrix(pointList, ref, ff, lf):\n\n\n    # The pointList argument is a list with knobs that holds XYz data. The list is in the following order: bottom left, bottom right, upper right, upper left.\n    # Returns a list containing matrix values.\n\n\n    animatedMatrix = \[]\n\n\n    projectionMatrixTo = nuke.math.Matrix4()\n    projectionMatrixFrom = nuke.math.Matrix4()\n\n\n    # Get the from values.\n    fromValues = \[]\n    for i in range(4):\n        for j in range(2):\n            fromValues.append(pointList\[i].valueAt(ref)\[j])\n\n\n    # Calculate the matrix.\n    for i in range(ff, lf+1):\n        toValues = \[]\n        for j in range(4):\n            for k in range(2):\n                to = pointList\[j].valueAt(i)\[k]\n                toValues.append(to)\n\n\n        projectionMatrixTo.mapUnitSquareToQuad(toValues\[0], toValues\[1], toValues\[2], toValues\[3], toValues\[4], toValues\[5], toValues\[6], toValues\[7])\n        projectionMatrixFrom.mapUnitSquareToQuad(fromValues\[0], fromValues\[1], fromValues\[2], fromValues\[3], fromValues\[4], fromValues\[5], fromValues\[6], fromValues\[7])\n\n\n        matrix = projectionMatrixTo*projectionMatrixFrom.inverse()    \n        matrix.transpose()\n\n\n        animatedMatrix.append(matrix)\n\n\n    return animatedMatrix\n\n\ndef add_animated_trackers(node, frame_start, values, trs=False):\n    # Add animated trackers.\n    num_tracks = len(values)\n\n\n    tracker_strings = \[]\n\n\n    if trs:\n        trs_val = \"1 1 1\"\n    else:\n        trs_val = \"1 0 0\"\n\n\n    for value in values:\n\n\n        name = value\n\n\n        x_list = \[]\n        y_list = \[]\n\n\n        for xy in values\[value]:\n            x,y = xy\n\n\n            x_list.append(str(x))\n            y_list.append(str(y))\n\n\n        x_str = \" \".join(x_list)\n        y_str = \" \".join(y_list)\n        frame_start = str(frame_start)\n\n\n        tracker_str = (\n            '\{ \{curve K x%s 1\} \"%s\" \{curve x%s %s\} \{curve x%s %s\}\\n'\n            '\{curve K x%s 0\} \{curve K x%s 0\} %s \{curve x%s 0\}\\n'\n            '1 0 -15 -15 15 15 -10 -10 10 10 \{\} \{\}  \{\}  \{\}  \{\}  \{\}  \{\}  \{\}  \{\}  \{\}  \{\}   \}'\n            ) % (\n                frame_start, name,\n                frame_start, x_str,\n                frame_start, y_str,\n                frame_start,\n                frame_start,\n                trs_val,\n                frame_start\n        )\n        \n        tracker_strings.append(tracker_str)\n\n\n    # Combine all tracker strings.\n    tracker_strings_combined = \"\{ \\n%s\\n\}\" % (\"\\n\".join(tracker_strings))\n\n\n    from_script_str = (\n        \"\{ 1 31 %s \}\\n\" \n        \"\{ \{ 5 1 20 enable e 1 \}\\n\"\n        \"\{ 3 1 75 name name 1 \}\\n\" \n        \"\{ 2 1 58 track_x track_x 1 \}\\n\" \n        \"\{ 2 1 58 track_y track_y 1 \}\\n\"\n        \"\{ 2 1 63 offset_x offset_x 1 \}\\n\"\n        \"\{ 2 1 63 offset_y offset_y 1 \}\\n\"\n        \"\{ 4 1 27 T T 1 \}\\n\"\n        \"\{ 4 1 27 R R 1 \}\\n\"\n        \"\{ 4 1 27 S S 1 \}\\n\"\n        \"\{ 2 0 45 error error 1 \}\\n\"\n        \"\{ 1 1 0 error_min error_min 1 \}\\n\"\n        \"\{ 1 1 0 error_max error_max 1 \}\\n\"\n        \"\{ 1 1 0 pattern_x pattern_x 1 \}\\n\"\n        \"\{ 1 1 0 pattern_y pattern_y 1 \}\\n\"\n        \"\{ 1 1 0 pattern_r pattern_r 1 \}\\n\"\n        \"\{ 1 1 0 pattern_t pattern_t 1 \}\\n\"\n        \"\{ 1 1 0 search_x search_x 1 \}\\n\"\n        \"\{ 1 1 0 search_y search_y 1 \}\\n\"\n        \"\{ 1 1 0 search_r search_r 1 \}\\n\"\n        \"\{ 1 1 0 search_t search_t 1 \}\\n\"\n        \"\{ 2 1 0 key_track key_track 1 \}\\n\"\n        \"\{ 2 1 0 key_search_x key_search_x 1 \}\\n\"\n        \"\{ 2 1 0 key_search_y key_search_y 1 \}\\n\"\n        \"\{ 2 1 0 key_search_r key_search_r 1 \}\\n\"\n        \"\{ 2 1 0 key_search_t key_search_t 1 \}\\n\" \n        \"\{ 2 1 0 key_track_x key_track_x 1 \}\\n\"\n        \"\{ 2 1 0 key_track_y key_track_y 1 \}\\n\"\n        \"\{ 2 1 0 key_track_r key_track_r 1 \}\\n\"\n        \"\{ 2 1 0 key_track_t key_track_t 1 \}\\n\"\n        \"\{ 2 1 0 key_centre_offset_x key_centre_offset_x 1 \}\\n\"\n        \"\{ 2 1 0 key_centre_offset_y key_centre_offset_y 1 \}\\n\"\n        \"\}\\n\" \n        \"%s\"\n    ) % (num_tracks, tracker_strings_combined)\n\n\n    try:\n        if node == None:\n            node = nuke.createNode(\"Tracker4\", inpanel=False)\n\n\n        tracks = node\[\"tracks\"]\n        tracks.fromScript(from_script_str.strip())\n        node\[\"zoom_window_behaviour\"].setValue(4)\n        node\[\"zoom_window_filter_behaviour\"].setValue(2)\n        node.setSelected(False)\n        node.setInput(0, None)\n\n\n        return node\n    except Exception as e:\n        print(e)\n\n\n        return False\n\n\n# Main function.\ndef sb_positionTracker():\n\n\n    n = nuke.thisNode()\n    n\[\"selected\"].setValue(False)\n\n\n    # 2D data knobs.\n    bl = n\[\"bl\"]\n    br = n\[\"br\"]\n    ur = n\[\"ur\"]\n    ul = n\[\"ul\"]\n\n\n    # Useful variables.\n    ref = int(n\[\"ref_frame\"].value())\n    ff = int(n\[\"ff\"].value())\n    lf = int(n\[\"lf\"].value())\n    outputNode = n\[\"output_node\"].value()\n\n\n    # Create node (in root).\n    with nuke.root():\n\n\n        if outputNode == \"CornerPin Match-move (Plane)\" or outputNode == \"CornerPin Stabilize (Plane)\":\n\n\n            c = nuke.createNode(\"CornerPin2D\")\n\n\n            # Add reference frame.\n            tab = nuke.Tab_Knob(\"ref\", \"Reference frame\")\n            c.addKnob(tab)\n            rf = nuke.Int_Knob(\"rf\")\n            c.addKnob(rf)\n            rf.setLabel(\"Reference frame\")\n            c\[\"rf\"].setValue(ref)\n            stf = nuke.PyScript_Knob('stf')\n            stf.setLabel(\"Set to this frame\")\n            c.addKnob(stf)\n            stf.setCommand( 'nuke.thisNode()\[\"rf\"].setValue(nuke.frame())' )\n\n\n            if outputNode == \"CornerPin Match-move (Plane)\":\n                cornerPinMain = \"to\"\n                cornerPinRef = \"from\"\n                cornerPinTransform = \"match-move\"\n            else:\n                cornerPinMain = \"from\"\n                cornerPinRef = \"to\"\n                cornerPinTransform = \"stabilize\"\n\n\n            main1 = \"\{0\}1\".format(cornerPinMain)\n            main2 = \"\{0\}2\".format(cornerPinMain)\n            main3 = \"\{0\}3\".format(cornerPinMain)\n            main4 = \"\{0\}4\".format(cornerPinMain)\n\n\n            c\[main1].copyAnimations(bl.animations())\n            c\[main2].copyAnimations(br.animations())\n            c\[main3].copyAnimations(ur.animations())\n            c\[main4].copyAnimations(ul.animations())\n\n\n            c\[\"\{0\}1\".format(cornerPinRef)].setExpression(\"\{0\}(rf)\".format(main1))\n            c\[\"\{0\}2\".format(cornerPinRef)].setExpression(\"\{0\}(rf)\".format(main2))\n            c\[\"\{0\}3\".format(cornerPinRef)].setExpression(\"\{0\}(rf)\".format(main3))\n            c\[\"\{0\}4\".format(cornerPinRef)].setExpression(\"\{0\}(rf)\".format(main4))\n\n\n            c\[\"label\"].setValue(\"\{0\}\\nreference frame: \[value rf]\".format(cornerPinTransform))\n\n\n        elif outputNode == \"Tracker\":\n\n\n            # Need Nuke 7.0 to create a Tracker node.\n            if int(nuke.NUKE_VERSION_MAJOR) < 7:\n                nuke.message(\"You need to use Nuke 7.0 (or newer) to create a Tracker node.\")\n                return\n\n\n            c = nuke.createNode(\"Tracker4\")\n\n\n            values = \{\n                \"Tracker1\": \[],\n                \"Tracker2\": \[],\n                \"Tracker3\": \[],\n                \"Tracker4\": \[],\n            \}\n\n\n            for frame in range(ff, lf+1):\n                for idx, corner_knob in enumerate(\[bl, br, ur, ul]):\n                    values\[\"Tracker\{0\}\".format(idx+1)].append(corner_knob.valueAt(frame))\n\n\n            add_animated_trackers(c, ff, values, trs=True)\n\n\n            c\[\"reference_frame\"].setValue(ref)\n            c\[\"label\"].setValue(\"reference frame: \[value reference_frame]\")\n\n\n        else:\n\n\n            # Get the matrix list.\n            matrixList = pointsToMatrix(\[bl, br, ur, ul], ref, ff, lf)\n\n\n            if outputNode == \"RotoPaint\" or outputNode == \"SplineWarp\":\n\n\n                if outputNode == \"RotoPaint\":\n                    c = nuke.createNode(\"RotoPaint\")\n                else:\n                    c = nuke.createNode(\"SplineWarp3\")\n\n\n                c\[\"selected\"].setValue(False)\n\n\n                curve = c\['curves']\n                root = curve.rootLayer\n                newLayer = rp.Layer(curve)\n                name = \"tracked layer\"\n                newLayer.name = name\n                root.append(newLayer)\n                curve.changed()\n                layer = curve.toElement(name)\n                transform = layer.getTransform()\n            \n                for i in range(ff, lf+1):\n                    matrixAtFrame = matrixList\[i-ff]\n                    for j in range(16):\n                        extraMatrixKnob = transform.getExtraMatrixAnimCurve(0,j)\n                        extraMatrixKnob.addKey(i,matrixAtFrame\[j])\n\n\n            else:\n\n\n                c = nuke.createNode(\"GridWarp3\")\n                c\[\"source_grid_transform_matrix\"].setAnimated()\n\n\n                # Setup progress bar.\n                task = nuke.ProgressTask('Adding keyframes...')\n                progressCalc = 100.0/float(lf-ff)\n                counter = 0\n\n\n                for i in range(ff, lf+1):\n                    matrixAtFrame = matrixList\[i-ff]\n                    for j in range(16):\n                        c\[\"source_grid_transform_matrix\"].setValueAt(matrixAtFrame\[j], i, j,)\n\n\n                    if task.isCancelled(): \n                        print(\"Cancelled by user.\")\n                        break\n\n\n                    # Update progressbar.\n                    task.setProgress(int(counter*progressCalc))\n                    task.setMessage(\"Frame \{0\}\".format(i))\n                    counter +=1\n\n\n                del task\n\n\n            c\[\"label\"].setValue(\"reference frame: \{0\}\".format(ref))\n\n\n        # Setup node.\n        c\[\"xpos\"].setValue(n\[\"xpos\"].value())\n        c\[\"ypos\"].setValue(n\[\"ypos\"].value()+100)\n        c\[\"selected\"].setValue(False)\n        c.setInput(0, None)\n\n\n# Run script.\nsb_positionTracker()" +STARTLINE}
addUserKnob {26 divider6 l "" +STARTLINE}
addUserKnob {7 version +INVISIBLE}
version 2.1
}
Input {
 inputs 0
 name camera
 label "\[value number]"
 xpos -42
 ypos 23
 number 2
}
Input {
 inputs 0
 name img
 label "\[value number]"
 xpos -244
 ypos -30
}
Output {
 name Output1
 xpos -244
 ypos 230
}
Input {
 inputs 0
 name position
 label "\[value number]"
 xpos -552
 ypos -22
 number 1
}
Shuffle {
 in rgb
 name position_to_rgb
 xpos -552
 ypos 99
}
NoOp {
 name pt_sampler
 xpos -552
 ypos 204
 addUserKnob {20 User}
 addUserKnob {18 bl_sampler l "bottom left"}
 bl_sampler {0 0 0}
 addUserKnob {6 bl_sampler_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 bl_sampler_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 br_sampler l "bottom right"}
 br_sampler {0 0 0}
 addUserKnob {6 br_sampler_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 br_sampler_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 ur_sampler l "upper right"}
 ur_sampler {0 0 0}
 addUserKnob {6 ur_sampler_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 ur_sampler_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 ul_sampler l "upper left"}
 ul_sampler {0 0 0}
 addUserKnob {6 ul_sampler_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 ul_sampler_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
}
end_group
